#summary Documentation of all annotations and how to use them

= Overview =

Annotations are probably the easiest way to publish data into the OPC UA address space. To use annotations 2 things have to be done:
 * Annotate the beans as desired
 * Use an instance of `AnnotationNodeManager` with an custom implementation of the IAnnotationSource interface 

= Annotations =

== Mandatory Annotations ==

Classes which are should be mapped to OPC UA Nodes have to be annotated with `@UaNode`
{{{
@UaNode
public class Floor {
...
}}}
The `@UaNode` annotations has a property nodeClass whose default value is  `NodeClass.Object`. Hence omitting this property leads the bean to be an OPC UA Object Node. The only values which are supported for nodeClass are
 * `NodeClass.Object` and
 * `NodeClass.Variable`

Every node has to be uniquely identified in the address space and needs a name which is displayed to the client. Therefore the `@ID` and `@DisplayName` annotations are used:
{{{
...

 /**
  * level of the floor
  */
 @ID
 private int level;

 /**
  * name of the floor
  */
 @DisplayName
 private String name;

...
}}}

With the annotations so far, every instance of `Floor` will be represented in the address space as a own node with the display name set to the `name` field and the `level` field will be part of the created ID for the node. 

== ID Generation ==

Nodes in the address space have to be uniquely identifiable, therefore some ID generation strategy has to be used. The current implementation concatenates the class name (without package information) with the value of the field which is annotated with @ID. So for example an instance of `Floor` with the field `level` set to 3 would be mapped to an OPC UA Node with an ID of `Floor:3`. But this is an implementation detail which should not bother you. Because only the class' name is used, no two classes with the same name (but different packages) are supported.

For the @ID field, every type which can be represented as `String` can be used.

Custom ID generators could be supported sometime in the future.

== Parent-Child relationships ==

Also known as one-to-many relationships are not describable by annotations at the moment, issue 4 will tackle this problem.

== Properties == 

== Variables ==

= Wiring everything up =

{{{
UAServer s = new UAServer();
...

AnnotationNodeManager annoNMgr = 
   new AnnotationNodeManager(
      new SampleNodeManager(),
      "my building",
      "contains some sample nodes of a building",
      "sampleBuilding"
   );

//add nodes to get introspected at startup -> this is a good practice
annoNMgr.addObjectToIntrospect(new Floor());
annoNMgr.addObjectToIntrospect(new Room());
s.addNodeManager(annoNMgr);

...
}}}